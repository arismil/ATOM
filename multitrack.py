# -*- coding: utf-8 -*-
"""Multitrack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17tcJaIKqksVYCQusLiCvOZsB6Cxn2Gsz

## Road Damage Detection
"""

import sys

from pip._internal.vcs import git

sys.path.append("C:/Users/aris/PycharmProjects/tracking/ATOM/utils")

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x
import numpy as np
import sys
import tarfile
import tensorflow as tf
import zipfile
from pprint import pprint
from collections import defaultdict
from io import StringIO
from matplotlib import pyplot as plt
from PIL import Image



from utils import label_map_util

from utils import visualization_utils as vis_util

#opencv stuff
import cv2
from sklearn.cluster import MeanShift, estimate_bandwidth, AgglomerativeClustering, MiniBatchKMeans
from skimage.color import label2rgb
from skimage import draw


def region_of_interest(img, vertices):
    mask = np.zeros_like(img)
    match_mask_color = 255 # <-- This line altered for grayscale.
    
    cv2.fillPoly(mask, vertices, match_mask_color)
    masked_image = cv2.bitwise_and(img, mask)
    return masked_image

def draw_lines(img, lines, color=[255, 0, 0], thickness=5):
    # If there are no lines to draw, exit.
    if lines is None:
        return
    # Make a copy of the original image.
    img = np.copy(img)
    # Create a blank image that matches the original in size.
    line_img = np.zeros(
        (
            img.shape[0],
            img.shape[1],
            3
        ),
        dtype=np.uint8,
    )
    # Loop over all lines and draw them on the blank image.
    for line in lines:
        for x1, y1, x2, y2 in line:
            cv2.line(line_img, (x1, y1), (x2, y2), color, thickness)
    # Merge the image with the lines onto the original.
    img = cv2.addWeighted(img, 0.8, line_img, 1.0, 0.0)
    # Return the modified image.
    return img

